"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var ts = require("typescript");
var assertNever_1 = require("../utils/assertNever");
var jsDocUtils_1 = require("./../utils/jsDocUtils");
var validatorUtils_1 = require("./../utils/validatorUtils");
var exceptions_1 = require("./exceptions");
var initializer_value_1 = require("./initializer-value");
var localReferenceTypeCache = {};
var inProgressTypes = {};
var TypeResolver = /** @class */ (function () {
    function TypeResolver(typeNode, current, parentNode, extractEnum, context) {
        if (extractEnum === void 0) { extractEnum = true; }
        if (context === void 0) { context = {}; }
        this.typeNode = typeNode;
        this.current = current;
        this.parentNode = parentNode;
        this.extractEnum = extractEnum;
        this.context = context;
        this.attemptToResolveKindToPrimitive = function (syntaxKind) {
            if (syntaxKind === ts.SyntaxKind.NumberKeyword) {
                return {
                    foundMatch: true,
                    resolvedType: 'number',
                };
            }
            else if (syntaxKind === ts.SyntaxKind.StringKeyword) {
                return {
                    foundMatch: true,
                    resolvedType: 'string',
                };
            }
            else if (syntaxKind === ts.SyntaxKind.BooleanKeyword) {
                return {
                    foundMatch: true,
                    resolvedType: 'boolean',
                };
            }
            else if (syntaxKind === ts.SyntaxKind.VoidKeyword) {
                return {
                    foundMatch: true,
                    resolvedType: 'void',
                };
            }
            else {
                return {
                    foundMatch: false,
                };
            }
        };
    }
    TypeResolver.clearCache = function () {
        Object.keys(localReferenceTypeCache).forEach(function (key) {
            delete localReferenceTypeCache[key];
        });
        Object.keys(inProgressTypes).forEach(function (key) {
            delete inProgressTypes[key];
        });
    };
    TypeResolver.prototype.resolve = function () {
        var _this = this;
        var primitiveType = this.getPrimitiveType(this.typeNode, this.parentNode);
        if (primitiveType) {
            return primitiveType;
        }
        if (this.typeNode.kind === ts.SyntaxKind.ArrayType) {
            var arrayMetaType = {
                dataType: 'array',
                elementType: new TypeResolver(this.typeNode.elementType, this.current, this.parentNode, this.extractEnum, this.context).resolve(),
            };
            return arrayMetaType;
        }
        if (ts.isUnionTypeNode(this.typeNode)) {
            var supportType = this.typeNode.types.every(function (type) { return ts.isLiteralTypeNode(type); });
            if (supportType) {
                var enumMetaType = {
                    dataType: 'enum',
                    enums: this.typeNode.types.map(function (type) { return _this.resolveLiteralValue(type); }),
                };
                return enumMetaType;
            }
            else {
                var types = this.typeNode.types.map(function (type) {
                    return new TypeResolver(type, _this.current, _this.parentNode, _this.extractEnum, _this.context).resolve();
                });
                var unionMetaType = {
                    dataType: 'union',
                    types: types,
                };
                return unionMetaType;
            }
        }
        if (ts.isIntersectionTypeNode(this.typeNode)) {
            var types = this.typeNode.types.map(function (type) {
                return new TypeResolver(type, _this.current, _this.parentNode, _this.extractEnum, _this.context).resolve();
            });
            var intersectionMetaType = {
                dataType: 'intersection',
                types: types,
            };
            return intersectionMetaType;
        }
        if (this.typeNode.kind === ts.SyntaxKind.AnyKeyword) {
            var literallyAny = {
                dataType: 'any',
            };
            return literallyAny;
        }
        if (ts.isLiteralTypeNode(this.typeNode)) {
            var enumType = {
                dataType: 'enum',
                enums: [this.resolveLiteralValue(this.typeNode)],
            };
            return enumType;
        }
        if (ts.isTypeLiteralNode(this.typeNode)) {
            var properties = this.typeNode.members
                .filter(function (member) { return ts.isPropertySignature(member); })
                .reduce(function (res, propertySignature) {
                var type = new TypeResolver(propertySignature.type, _this.current, propertySignature, _this.extractEnum, _this.context).resolve();
                var property = {
                    default: jsDocUtils_1.getJSDocComment(propertySignature, 'default'),
                    description: _this.getNodeDescription(propertySignature),
                    format: _this.getNodeFormat(propertySignature),
                    name: propertySignature.name.text,
                    required: !propertySignature.questionToken,
                    type: type,
                    validators: validatorUtils_1.getPropertyValidators(propertySignature) || {},
                };
                return __spread([property], res);
            }, []);
            var indexMember = this.typeNode.members.find(function (member) { return ts.isIndexSignatureDeclaration(member); });
            var additionalType = void 0;
            if (indexMember) {
                var indexSignatureDeclaration = indexMember;
                var indexType = new TypeResolver(indexSignatureDeclaration.parameters[0].type, this.current, this.parentNode, this.extractEnum, this.context).resolve();
                if (indexType.dataType !== 'string') {
                    throw new exceptions_1.GenerateMetadataError("Only string indexers are supported.", this.typeNode);
                }
                additionalType = new TypeResolver(indexSignatureDeclaration.type, this.current, this.parentNode, this.extractEnum, this.context).resolve();
            }
            var objLiteral = {
                additionalProperties: indexMember && additionalType,
                dataType: 'nestedObjectLiteral',
                properties: properties,
            };
            return objLiteral;
        }
        if (this.typeNode.kind === ts.SyntaxKind.ObjectKeyword) {
            return { dataType: 'object' };
        }
        if (this.typeNode.kind !== ts.SyntaxKind.TypeReference) {
            throw new exceptions_1.GenerateMetadataError("Unknown type: " + ts.SyntaxKind[this.typeNode.kind], this.typeNode);
        }
        var typeReference = this.typeNode;
        if (typeReference.typeName.kind === ts.SyntaxKind.Identifier) {
            if (typeReference.typeName.text === 'Date') {
                return this.getDateType(this.parentNode);
            }
            if (typeReference.typeName.text === 'Buffer') {
                var bufferMetaType = { dataType: 'buffer' };
                return bufferMetaType;
            }
            if (typeReference.typeName.text === 'Array' && typeReference.typeArguments && typeReference.typeArguments.length === 1) {
                var arrayMetaType = {
                    dataType: 'array',
                    elementType: new TypeResolver(typeReference.typeArguments[0], this.current, this.parentNode, this.extractEnum, this.context).resolve(),
                };
                return arrayMetaType;
            }
            if (typeReference.typeName.text === 'Promise' && typeReference.typeArguments && typeReference.typeArguments.length === 1) {
                return new TypeResolver(typeReference.typeArguments[0], this.current, this.parentNode, this.extractEnum, this.context).resolve();
            }
            if (typeReference.typeName.text === 'String') {
                var stringMetaType = { dataType: 'string' };
                return stringMetaType;
            }
            if (this.context[typeReference.typeName.text]) {
                return new TypeResolver(this.context[typeReference.typeName.text], this.current, this.parentNode, this.extractEnum, this.context).resolve();
            }
        }
        if (!this.extractEnum) {
            var enumType = this.getEnumerateType(typeReference.typeName, this.extractEnum);
            if (enumType) {
                return enumType;
            }
        }
        var literalType = this.getLiteralType(typeReference.typeName);
        if (literalType) {
            return literalType;
        }
        if (typeReference.typeArguments && typeReference.typeArguments.length > 0) {
            this.typeArgumentsToContext(typeReference, typeReference.typeName, this.context);
        }
        var enumOrReferenceType = this.getReferenceTypeOrEnumType(typeReference.typeName, this.extractEnum, typeReference.typeArguments);
        if (enumOrReferenceType.dataType === 'refEnum' || enumOrReferenceType.dataType === 'refObject') {
            this.checkRefNameForBadCharacters(enumOrReferenceType);
            this.current.AddReferenceType(enumOrReferenceType);
            return enumOrReferenceType;
        }
        else if (enumOrReferenceType.dataType === 'enum') {
            // then there is no reference to add to the reference type map
            // but we should still return it (if they want it)
            if (!this.extractEnum) {
                return enumOrReferenceType;
            }
        }
        else {
            assertNever_1.assertNever(enumOrReferenceType);
        }
        return enumOrReferenceType;
    };
    TypeResolver.prototype.resolveLiteralValue = function (typeNode) {
        var value;
        switch (typeNode.literal.kind) {
            case ts.SyntaxKind.TrueKeyword:
                value = 'true';
                break;
            case ts.SyntaxKind.FalseKeyword:
                value = 'false';
                break;
            case ts.SyntaxKind.StringLiteral:
                value = typeNode.literal.text;
                break;
            case ts.SyntaxKind.NumericLiteral:
                value = typeNode.literal.text;
                break;
            default:
                if (typeNode.literal.hasOwnProperty('text')) {
                    value = typeNode.literal.text;
                }
                else {
                    throw new exceptions_1.GenerateMetadataError("Couldn't resolve literal node: " + typeNode.literal.getText());
                }
        }
        return value;
    };
    TypeResolver.prototype.checkRefNameForBadCharacters = function (ref) {
        // We do a hard assert in the test mode so we can catch bad ref names (https://github.com/lukeautry/tsoa/issues/398).
        //   The goal is to avoid producing these names before the code is ever merged to master (via extensive test coverage)
        //   and therefore this validation does not have to run for the users
        if (process.env.NODE_ENV === 'tsoa_test') {
            // This regex allows underscore, hyphen, and period since those are valid in SwaggerEditor
            var symbolsRegex = /[!$%^&*()+|~=`{}\[\]:";'<>?,\/]/;
            if (symbolsRegex.test(ref.refName)) {
                throw new Error("Problem with creating refName " + ref.refName + " since we should not allow symbols in ref names " +
                    "because it would cause invalid swagger.yaml to be created. This is due to the swagger rule " +
                    "\"ref values must be RFC3986-compliant percent-encoded URIs.\"");
            }
        }
    };
    TypeResolver.prototype.getPrimitiveType = function (typeNode, parentNode) {
        var resolution = this.attemptToResolveKindToPrimitive(typeNode.kind);
        if (!resolution.foundMatch) {
            return;
        }
        if (resolution.resolvedType === 'number') {
            if (!parentNode) {
                return { dataType: 'double' };
            }
            var tags = jsDocUtils_1.getJSDocTagNames(parentNode).filter(function (name) {
                return ['isInt', 'isLong', 'isFloat', 'isDouble'].some(function (m) { return m === name; });
            });
            if (tags.length === 0) {
                return { dataType: 'double' };
            }
            switch (tags[0]) {
                case 'isInt':
                    return { dataType: 'integer' };
                case 'isLong':
                    return { dataType: 'long' };
                case 'isFloat':
                    return { dataType: 'float' };
                case 'isDouble':
                    return { dataType: 'double' };
                default:
                    return { dataType: 'double' };
            }
        }
        else if (resolution.resolvedType === 'string') {
            return {
                dataType: 'string',
            };
        }
        else if (resolution.resolvedType === 'boolean') {
            return {
                dataType: 'boolean',
            };
        }
        else if (resolution.resolvedType === 'void') {
            return {
                dataType: 'void',
            };
        }
        else {
            return assertNever_1.assertNever(resolution.resolvedType);
        }
    };
    TypeResolver.prototype.getDateType = function (parentNode) {
        if (!parentNode) {
            return { dataType: 'datetime' };
        }
        var tags = jsDocUtils_1.getJSDocTagNames(parentNode).filter(function (name) {
            return ['isDate', 'isDateTime'].some(function (m) { return m === name; });
        });
        if (tags.length === 0) {
            return { dataType: 'datetime' };
        }
        switch (tags[0]) {
            case 'isDate':
                return { dataType: 'date' };
            case 'isDateTime':
                return { dataType: 'datetime' };
            default:
                return { dataType: 'datetime' };
        }
    };
    TypeResolver.prototype.getEnumerateType = function (typeName, extractEnum) {
        if (extractEnum === void 0) { extractEnum = true; }
        var enumName = typeName.text;
        var enumNodes = this.current.nodes.filter(function (node) { return node.kind === ts.SyntaxKind.EnumDeclaration; }).filter(function (node) { return node.name.text === enumName; });
        if (!enumNodes.length) {
            return;
        }
        if (enumNodes.length > 1) {
            throw new exceptions_1.GenerateMetadataError("Multiple matching enum found for enum " + enumName + "; please make enum names unique.");
        }
        var enumDeclaration = enumNodes[0];
        var typeChecker = this.current.typeChecker;
        function getEnumValue(member) {
            var constantValue = typeChecker.getConstantValue(member);
            if (constantValue != null) {
                return constantValue;
            }
            var initializer = member.initializer;
            if (initializer) {
                if (initializer.expression) {
                    return initializer.expression.text;
                }
                return initializer.text;
            }
            return;
        }
        if (extractEnum) {
            var enums = enumDeclaration.members.map(function (member, index) {
                var enumValue = getEnumValue(member);
                if (enumValue !== 0 && enumValue !== '' && !enumValue) {
                    return String(index);
                }
                return enumValue;
            });
            return {
                dataType: 'refEnum',
                description: this.getNodeDescription(enumDeclaration),
                enums: enums,
                refName: enumName,
            };
        }
        else {
            return {
                dataType: 'enum',
                enums: enumDeclaration.members.map(function (member, index) {
                    return getEnumValue(member) || String(index);
                }),
            };
        }
    };
    TypeResolver.prototype.getLiteralType = function (typeName) {
        var literalName = typeName.text;
        var literalTypes = this.current.nodes
            .filter(function (node) { return node.kind === ts.SyntaxKind.TypeAliasDeclaration; })
            .filter(function (node) {
            var innerType = node.type;
            return innerType.kind === ts.SyntaxKind.UnionType && innerType.types;
        })
            .filter(function (node) { return node.name.text === literalName; });
        if (!literalTypes.length) {
            return;
        }
        if (literalTypes.length > 1) {
            throw new exceptions_1.GenerateMetadataError("Multiple matching enum found for enum " + literalName + "; please make enum names unique.");
        }
        var unionTypes = literalTypes[0].type.types;
        if (unionTypes.some(function (t) { return !t.literal || !t.literal.text; })) {
            // tagged union types can't be expressed in Swagger terms, probably
            return { dataType: 'any' };
        }
        return {
            dataType: 'enum',
            enums: unionTypes.map(function (unionNode) { return unionNode.literal.text; }),
        };
    };
    TypeResolver.prototype.getReferenceTypeOrEnumType = function (type, extractEnum, genericTypes) {
        if (extractEnum === void 0) { extractEnum = true; }
        var typeName = this.resolveFqTypeName(type);
        var refNameWithGenerics = this.getTypeName(typeName, genericTypes);
        try {
            var existingType = localReferenceTypeCache[refNameWithGenerics];
            if (existingType) {
                return existingType;
            }
            var enumOrRefEnum = this.getEnumerateType(type, true);
            if (enumOrRefEnum) {
                if (enumOrRefEnum.dataType === 'refEnum') {
                    localReferenceTypeCache[refNameWithGenerics] = enumOrRefEnum;
                    return enumOrRefEnum;
                }
                else if (enumOrRefEnum.dataType === 'enum') {
                    // Since an enum that is not reusable can't be referenced, we don't put it in the cache.
                    // Also it doesn't qualify as a ref type, so might want to return it (if they've asked for it)
                    if (!extractEnum) {
                        return enumOrRefEnum;
                    }
                }
                else {
                    assertNever_1.assertNever(enumOrRefEnum);
                }
            }
            if (inProgressTypes[refNameWithGenerics]) {
                return this.createCircularDependencyResolver(refNameWithGenerics);
            }
            inProgressTypes[refNameWithGenerics] = true;
            var modelType = this.getModelTypeDeclaration(type);
            var properties = this.getModelProperties(modelType, genericTypes);
            var additionalProperties = this.getModelAdditionalProperties(modelType);
            var inheritedProperties = this.getModelInheritedProperties(modelType) || [];
            var example = this.getNodeExample(modelType);
            var referenceType = {
                additionalProperties: additionalProperties,
                dataType: 'refObject',
                description: this.getNodeDescription(modelType),
                properties: inheritedProperties,
                refName: refNameWithGenerics,
            };
            referenceType.properties = referenceType.properties.concat(properties);
            localReferenceTypeCache[refNameWithGenerics] = referenceType;
            if (example) {
                referenceType.example = example;
            }
            return referenceType;
        }
        catch (err) {
            // tslint:disable-next-line:no-console
            console.error("There was a problem resolving type of '" + this.getTypeName(typeName, genericTypes) + "'.");
            throw err;
        }
    };
    TypeResolver.prototype.resolveFqTypeName = function (type) {
        if (type.kind === ts.SyntaxKind.Identifier) {
            return type.text;
        }
        var qualifiedType = type;
        return this.resolveFqTypeName(qualifiedType.left) + '.' + qualifiedType.right.text;
    };
    TypeResolver.prototype.getTypeName = function (typeName, genericTypes) {
        var _this = this;
        if (!genericTypes || !genericTypes.length) {
            return typeName;
        }
        var resolvedName = genericTypes
            .map(function (genericType) { return _this.context[genericType.getText()] || genericType; })
            .reduce(function (acc, generic) {
            if (ts.isTypeReferenceNode(generic) && generic.typeArguments && generic.typeArguments.length > 0) {
                var typeNameSection = _this.getTypeName(generic.typeName.getText(), generic.typeArguments);
                acc.push(typeNameSection);
                return acc;
            }
            else {
                var typeNameSection = _this.getAnyTypeName(generic);
                acc.push(typeNameSection);
                return acc;
            }
        }, []);
        var finalName = typeName + resolvedName.join('');
        return finalName;
    };
    TypeResolver.prototype.getAnyTypeName = function (typeNode) {
        var primitiveType = this.attemptToResolveKindToPrimitive(typeNode.kind);
        if (primitiveType.foundMatch) {
            return primitiveType.resolvedType;
        }
        if (typeNode.kind === ts.SyntaxKind.ArrayType) {
            var arrayType = typeNode;
            return this.getAnyTypeName(arrayType.elementType) + 'Array';
        }
        if (typeNode.kind === ts.SyntaxKind.UnionType) {
            return 'object';
        }
        if (typeNode.kind !== ts.SyntaxKind.TypeReference) {
            throw new exceptions_1.GenerateMetadataError("Unknown type: " + ts.SyntaxKind[typeNode.kind] + ".", this.typeNode);
        }
        var typeReference = typeNode;
        try {
            return typeReference.typeName.text;
        }
        catch (e) {
            // idk what would hit this? probably needs more testing
            // tslint:disable-next-line:no-console
            console.error(e);
            return typeNode.toString();
        }
    };
    TypeResolver.prototype.createCircularDependencyResolver = function (refName) {
        var referenceType = {
            dataType: 'refObject',
            refName: refName,
        };
        this.current.OnFinish(function (referenceTypes) {
            var realReferenceType = referenceTypes[refName];
            if (!realReferenceType) {
                return;
            }
            referenceType.description = realReferenceType.description;
            if (realReferenceType.dataType === 'refObject' && referenceType.dataType === 'refObject') {
                referenceType.properties = realReferenceType.properties;
            }
            referenceType.dataType = realReferenceType.dataType;
            referenceType.refName = referenceType.refName;
        });
        return referenceType;
    };
    TypeResolver.prototype.nodeIsUsable = function (node) {
        switch (node.kind) {
            case ts.SyntaxKind.InterfaceDeclaration:
            case ts.SyntaxKind.ClassDeclaration:
            case ts.SyntaxKind.TypeAliasDeclaration:
            case ts.SyntaxKind.EnumDeclaration:
                return true;
            default:
                return false;
        }
    };
    TypeResolver.prototype.resolveLeftmostIdentifier = function (type) {
        while (type.kind !== ts.SyntaxKind.Identifier) {
            type = type.left;
        }
        return type;
    };
    TypeResolver.prototype.resolveModelTypeScope = function (leftmost, statements) {
        var _this = this;
        var _loop_1 = function () {
            var leftmostName = leftmost.kind === ts.SyntaxKind.Identifier ? leftmost.text : leftmost.right.text;
            var moduleDeclarations = statements.filter(function (node) {
                if (node.kind !== ts.SyntaxKind.ModuleDeclaration || !_this.current.IsExportedNode(node)) {
                    return false;
                }
                var moduleDeclaration = node;
                return moduleDeclaration.name.text.toLowerCase() === leftmostName.toLowerCase();
            });
            if (!moduleDeclarations.length) {
                throw new exceptions_1.GenerateMetadataError("No matching module declarations found for " + leftmostName + ".");
            }
            if (moduleDeclarations.length > 1) {
                throw new exceptions_1.GenerateMetadataError("Multiple matching module declarations found for " + leftmostName + "; please make module declarations unique.");
            }
            var moduleBlock = moduleDeclarations[0].body;
            if (moduleBlock === null || moduleBlock.kind !== ts.SyntaxKind.ModuleBlock) {
                throw new exceptions_1.GenerateMetadataError("Module declaration found for " + leftmostName + " has no body.");
            }
            statements = moduleBlock.statements;
            leftmost = leftmost.parent;
        };
        while (leftmost.parent && leftmost.parent.kind === ts.SyntaxKind.QualifiedName) {
            _loop_1();
        }
        return statements;
    };
    TypeResolver.prototype.getModelTypeDeclaration = function (type) {
        var _this = this;
        var leftmostIdentifier = this.resolveLeftmostIdentifier(type);
        var statements = this.resolveModelTypeScope(leftmostIdentifier, this.current.nodes);
        var typeName = type.kind === ts.SyntaxKind.Identifier ? type.text : type.right.text;
        var modelTypes = statements.filter(function (node) {
            if (!_this.nodeIsUsable(node) || !_this.current.IsExportedNode(node)) {
                return false;
            }
            var modelTypeDeclaration = node;
            return modelTypeDeclaration.name.text === typeName;
        });
        if (!modelTypes.length) {
            throw new exceptions_1.GenerateMetadataError("No matching model found for referenced type " + typeName + ". If " + typeName + " comes from a dependency, please create an interface in your own code that has the same structure. Tsoa can not utilize interfaces from external dependencies. Read more at https://github.com/lukeautry/tsoa/blob/master/docs/ExternalInterfacesExplanation.MD");
        }
        if (modelTypes.length > 1) {
            // remove types that are from typescript e.g. 'Account'
            modelTypes = modelTypes.filter(function (modelType) {
                if (modelType
                    .getSourceFile()
                    .fileName.replace(/\\/g, '/')
                    .toLowerCase()
                    .indexOf('node_modules/typescript') > -1) {
                    return false;
                }
                return true;
            });
            /**
             * Model is marked with '@tsoaModel', indicating that it should be the 'canonical' model used
             */
            var designatedModels = modelTypes.filter(function (modelType) {
                var isDesignatedModel = jsDocUtils_1.isExistJSDocTag(modelType, function (tag) { return tag.tagName.text === 'tsoaModel'; });
                return isDesignatedModel;
            });
            if (designatedModels.length > 0) {
                if (designatedModels.length > 1) {
                    throw new exceptions_1.GenerateMetadataError("Multiple models for " + typeName + " marked with '@tsoaModel'; '@tsoaModel' should only be applied to one model.");
                }
                modelTypes = designatedModels;
            }
        }
        if (modelTypes.length > 1) {
            var conflicts = modelTypes.map(function (modelType) { return modelType.getSourceFile().fileName; }).join('"; "');
            throw new exceptions_1.GenerateMetadataError("Multiple matching models found for referenced type " + typeName + "; please make model names unique. Conflicts found: \"" + conflicts + "\".");
        }
        return modelTypes[0];
    };
    TypeResolver.prototype.getModelProperties = function (node, genericTypes) {
        var _this = this;
        var isIgnored = function (e) {
            var ignore = jsDocUtils_1.isExistJSDocTag(e, function (tag) { return tag.tagName.text === 'ignore'; });
            return ignore;
        };
        // Interface model
        if (node.kind === ts.SyntaxKind.InterfaceDeclaration) {
            var interfaceDeclaration = node;
            return interfaceDeclaration.members
                .filter(function (member) {
                var ignore = isIgnored(member);
                return !ignore && member.kind === ts.SyntaxKind.PropertySignature;
            })
                .map(function (member) {
                var propertyDeclaration = member;
                var identifier = propertyDeclaration.name;
                if (!propertyDeclaration.type) {
                    throw new exceptions_1.GenerateMetadataError("No valid type found for property declaration.");
                }
                return {
                    default: jsDocUtils_1.getJSDocComment(propertyDeclaration, 'default'),
                    description: _this.getNodeDescription(propertyDeclaration),
                    format: _this.getNodeFormat(propertyDeclaration),
                    name: identifier.text,
                    required: !propertyDeclaration.questionToken,
                    type: new TypeResolver(propertyDeclaration.type, _this.current, propertyDeclaration.type.parent, _this.extractEnum, _this.context).resolve(),
                    validators: validatorUtils_1.getPropertyValidators(propertyDeclaration),
                };
            });
        }
        // Type alias model
        if (node.kind === ts.SyntaxKind.TypeAliasDeclaration) {
            var aliasDeclaration = node;
            var properties_1 = [];
            if (aliasDeclaration.type.kind === ts.SyntaxKind.IntersectionType) {
                var intersectionTypeNode = aliasDeclaration.type;
                intersectionTypeNode.types.forEach(function (type) {
                    if (type.kind === ts.SyntaxKind.TypeReference) {
                        var typeReferenceNode = type;
                        var modelType = _this.getModelTypeDeclaration(typeReferenceNode.typeName);
                        var modelProps = _this.getModelProperties(modelType);
                        properties_1.push.apply(properties_1, __spread(modelProps));
                    }
                });
            }
            if (aliasDeclaration.type.kind === ts.SyntaxKind.TypeReference) {
                var typeReferenceNode = aliasDeclaration.type;
                var modelType = this.getModelTypeDeclaration(typeReferenceNode.typeName);
                var modelProps = this.getModelProperties(modelType);
                properties_1.push.apply(properties_1, __spread(modelProps));
            }
            return properties_1;
        }
        // Class model
        var classDeclaration = node;
        var properties = classDeclaration.members
            .filter(function (member) {
            var ignore = isIgnored(member);
            return !ignore;
        })
            .filter(function (member) { return member.kind === ts.SyntaxKind.PropertyDeclaration; })
            .filter(function (member) { return _this.hasPublicModifier(member); });
        var classConstructor = classDeclaration.members.find(function (member) { return member.kind === ts.SyntaxKind.Constructor; });
        if (classConstructor && classConstructor.parameters) {
            var constructorProperties = classConstructor.parameters.filter(function (parameter) { return _this.isAccessibleParameter(parameter); });
            properties.push.apply(properties, __spread(constructorProperties));
        }
        return properties.map(function (property) {
            var identifier = property.name;
            var typeNode = property.type;
            if (!typeNode) {
                var tsType = _this.current.typeChecker.getTypeAtLocation(property);
                typeNode = _this.current.typeChecker.typeToTypeNode(tsType);
            }
            if (!typeNode) {
                throw new exceptions_1.GenerateMetadataError("No valid type found for property declaration.");
            }
            var type = new TypeResolver(typeNode, _this.current, property, _this.extractEnum, _this.context).resolve();
            return {
                default: initializer_value_1.getInitializerValue(property.initializer, type),
                description: _this.getNodeDescription(property),
                format: _this.getNodeFormat(property),
                name: identifier.text,
                required: !property.questionToken && !property.initializer,
                type: type,
                validators: validatorUtils_1.getPropertyValidators(property),
            };
        });
    };
    TypeResolver.prototype.getModelAdditionalProperties = function (node) {
        if (node.kind === ts.SyntaxKind.InterfaceDeclaration) {
            var interfaceDeclaration = node;
            var indexMember = interfaceDeclaration.members.find(function (member) { return member.kind === ts.SyntaxKind.IndexSignature; });
            if (!indexMember) {
                return undefined;
            }
            var indexSignatureDeclaration = indexMember;
            var indexType = new TypeResolver(indexSignatureDeclaration.parameters[0].type, this.current, this.parentNode, this.extractEnum, this.context).resolve();
            if (indexType.dataType !== 'string') {
                throw new exceptions_1.GenerateMetadataError("Only string indexers are supported.", this.typeNode);
            }
            return new TypeResolver(indexSignatureDeclaration.type, this.current, this.parentNode, this.extractEnum, this.context).resolve();
        }
        return undefined;
    };
    TypeResolver.prototype.typeArgumentsToContext = function (type, targetEntitiy, context) {
        var _a;
        this.context = {};
        if (type.typeArguments && type.typeArguments.length > 0) {
            var typeParameters = this.getModelTypeDeclaration(targetEntitiy).typeParameters;
            if (typeParameters) {
                for (var index = 0; index < typeParameters.length; index++) {
                    var typeParameter = typeParameters[index];
                    var typeArg = type.typeArguments[index];
                    var resolvedType = void 0;
                    // Argument may be a forward reference from context
                    if (ts.isTypeReferenceNode(typeArg) && ts.isIdentifier(typeArg.typeName) && context[typeArg.typeName.text]) {
                        resolvedType = context[typeParameter.name.text];
                    }
                    else {
                        resolvedType = type.typeArguments[index];
                    }
                    this.context = __assign({}, this.context, (_a = {}, _a[typeParameter.name.text] = resolvedType, _a));
                }
            }
        }
        return context;
    };
    TypeResolver.prototype.getModelInheritedProperties = function (modelTypeDeclaration) {
        var _this = this;
        var properties = [];
        if (modelTypeDeclaration.kind === ts.SyntaxKind.TypeAliasDeclaration) {
            return [];
        }
        var heritageClauses = modelTypeDeclaration.heritageClauses;
        if (!heritageClauses) {
            return properties;
        }
        heritageClauses.forEach(function (clause) {
            if (!clause.types) {
                return;
            }
            clause.types.forEach(function (t) {
                var baseEntityName = t.expression;
                // create subContext
                var resetCtx = _this.context;
                if (t.typeArguments && t.typeArguments.length > 0) {
                    resetCtx = _this.typeArgumentsToContext(t, baseEntityName, _this.context);
                }
                var referenceType = _this.getReferenceTypeOrEnumType(baseEntityName);
                if (referenceType) {
                    if (referenceType.dataType === 'refEnum' || referenceType.dataType === 'enum') {
                        // since it doesn't have properties to iterate over, then we don't do anything with it
                    }
                    else if (referenceType.dataType === 'refObject') {
                        referenceType.properties.forEach(function (property) { return properties.push(property); });
                    }
                    else {
                        assertNever_1.assertNever(referenceType);
                    }
                }
                // reset subContext
                _this.context = resetCtx;
            });
        });
        return properties;
    };
    TypeResolver.prototype.hasPublicModifier = function (node) {
        return (!node.modifiers ||
            node.modifiers.every(function (modifier) {
                return modifier.kind !== ts.SyntaxKind.ProtectedKeyword && modifier.kind !== ts.SyntaxKind.PrivateKeyword;
            }));
    };
    TypeResolver.prototype.isAccessibleParameter = function (node) {
        // No modifiers
        if (!node.modifiers) {
            return false;
        }
        // public || public readonly
        if (node.modifiers.some(function (modifier) { return modifier.kind === ts.SyntaxKind.PublicKeyword; })) {
            return true;
        }
        // readonly, not private readonly, not public readonly
        var isReadonly = node.modifiers.some(function (modifier) { return modifier.kind === ts.SyntaxKind.ReadonlyKeyword; });
        var isProtectedOrPrivate = node.modifiers.some(function (modifier) {
            return modifier.kind === ts.SyntaxKind.ProtectedKeyword || modifier.kind === ts.SyntaxKind.PrivateKeyword;
        });
        return isReadonly && !isProtectedOrPrivate;
    };
    TypeResolver.prototype.getNodeDescription = function (node) {
        var symbol = this.current.typeChecker.getSymbolAtLocation(node.name);
        if (!symbol) {
            return undefined;
        }
        /**
         * TODO: Workaround for what seems like a bug in the compiler
         * Warrants more investigation and possibly a PR against typescript
         */
        if (node.kind === ts.SyntaxKind.Parameter) {
            // TypeScript won't parse jsdoc if the flag is 4, i.e. 'Property'
            symbol.flags = 0;
        }
        var comments = symbol.getDocumentationComment(this.current.typeChecker);
        if (comments.length) {
            return ts.displayPartsToString(comments);
        }
        return undefined;
    };
    TypeResolver.prototype.getNodeFormat = function (node) {
        return jsDocUtils_1.getJSDocComment(node, 'format');
    };
    TypeResolver.prototype.getNodeExample = function (node) {
        var example = jsDocUtils_1.getJSDocComment(node, 'example');
        if (example) {
            return JSON.parse(example);
        }
        else {
            return undefined;
        }
    };
    return TypeResolver;
}());
exports.TypeResolver = TypeResolver;
//# sourceMappingURL=typeResolver.js.map